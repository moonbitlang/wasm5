// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/wasm5/src/runtime"

import(
  "moonbitlang/wasm5/src/core"
)

// Values
pub let canonical_nan_f32 : Float

pub let canonical_nan_f64 : Double

pub fn default_import_resolver() -> ImportResolver

pub fn rint(Double) -> Double

pub fn rintf(Float) -> Float

// Errors
pub suberror RuntimeError {
  DivisionByZero
  IntegerOverflow
  MemoryOutOfBounds
  InvalidType(String)
  FunctionNotFound(String)
  Unreachable
  FunctionNotCompiled(String)
  UnsupportedInitExpression(String)
  StackOverflow
}
pub impl Show for RuntimeError

// Types and methods
pub struct CompileBlock {
  kind : CompileBlockKind
  params : Array[@core.ValType]
  results : Array[@core.ValType]
  stack_height_at_entry : Int
  target_pc : Int
  pending_br_patches : Array[Int]
}

pub enum CompileBlockKind {
  BlockKind
  LoopKind
  IfKind
}
pub impl Eq for CompileBlockKind

pub struct CompileCtx {
  type_stack : Array[@core.ValType]
  control_stack : Array[CompileBlock]
  func_result_count : Int
  mut max_stack_depth : Int
}

pub struct Compiler {
  module_ : @core.Module
  ops : Array[UInt64]
  pending_call_patches : Array[PendingCallPatch]
}
pub fn Compiler::compile(Self) -> Unit raise RuntimeError
pub fn Compiler::finish(Self) -> FixedArray[UInt64]
pub fn Compiler::new(@core.Module) -> Self

pub struct ImportResolver {
  modules : Map[Bytes, ImportResolverEntry]
}
pub fn ImportResolver::add_func(Self, Bytes, Bytes, ImportedFunc) -> Unit
pub fn ImportResolver::add_global(Self, Bytes, Bytes, Value) -> Unit
pub fn ImportResolver::add_memory(Self, Bytes, Bytes, ImportedMemory) -> Unit
pub fn ImportResolver::add_table(Self, Bytes, Bytes, RuntimeTable) -> Unit
pub fn ImportResolver::get_func(Self, Bytes, Bytes) -> ImportedFunc?
pub fn ImportResolver::get_global(Self, Bytes, Bytes) -> Value?
pub fn ImportResolver::get_memory(Self, Bytes, Bytes) -> ImportedMemory?
pub fn ImportResolver::get_table(Self, Bytes, Bytes) -> RuntimeTable?
pub fn ImportResolver::new() -> Self

type ImportResolverEntry

pub struct ImportedFunc {
  arity : UInt
  func : (Array[Value]) -> Array[Value]
}
pub fn ImportedFunc::new(UInt, (Array[Value]) -> Array[Value]) -> Self

pub struct ImportedMemory {
  data : Array[Byte]
  max : UInt64?
}
pub fn ImportedMemory::new(Array[Byte], UInt64?) -> Self

type PendingCallPatch

pub struct Runtime {
  ops : FixedArray[UInt64]
  stack : FixedArray[UInt64]
  mut sp : Int
  mut bp : Int
  mut num_locals : Int
  mut pc : Int
  ctx : RuntimeContext
}
pub fn Runtime::call_compiled(Self, Bytes, Array[Value]) -> (Self, Array[Value]) raise RuntimeError
pub fn Runtime::compile(Self) -> Self raise RuntimeError
pub fn Runtime::get_globals(Self) -> Array[Value]
pub fn Runtime::get_module(Self) -> @core.Module
pub fn Runtime::get_tables(Self) -> Array[RuntimeTable]
pub fn Runtime::load(@core.Module) -> Self raise RuntimeError
pub fn Runtime::load_with_resolver(@core.Module, ImportResolver) -> Self raise RuntimeError

pub struct RuntimeContext {
  module_ : @core.Module
  compiled : @core.CompiledModule
  memory : Array[Byte]
  memory_max : UInt64?
  globals : Array[Value]
  tables : Array[RuntimeTable]
  imported_funcs : Array[ImportedFunc]
  data_segments : Array[Array[Byte]]
  mut error_detail : String
}

#alias(ReturnCode)
pub enum RuntimeStatus {
  Running
  Terminated
  Trap
  Returned
}
pub impl Eq for RuntimeStatus
pub impl Show for RuntimeStatus

type RuntimeTable

pub(all) enum Value {
  I32(UInt)
  I64(UInt64)
  F32(Float)
  F64(Double)
  Ref(Int?)
}
pub impl Eq for Value
pub impl Show for Value

// Type aliases

// Traits

