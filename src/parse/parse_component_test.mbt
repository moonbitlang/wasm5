///|
test "parse simple component" {
  // Component binary created by: wasm-tools component new core.wasm
  // Section 1 (Core Module) with an "add" function
  // Header: 00 61 73 6d 0d 00 01 00 (magic, version 13, layer 1)
  // Section 1 (Core Module): 01 29 <41 bytes of core module>
  let bytes : Bytes = b"\x00\x61\x73\x6d\x0d\x00\x01\x00\x01\x29\x00\x61\x73\x6d\x01\x00\x00\x00\x01\x07\x01\x60\x02\x7f\x7f\x01\x7f\x03\x02\x01\x00\x07\x07\x01\x03\x61\x64\x64\x00\x00\x0a\x09\x01\x07\x00\x20\x00\x20\x01\x6a\x0b"
  let component = parse_component(bytes)
  // Should have at least one section (the core module)
  assert_true(component.sections.length() >= 1)
  // First section should be a core module
  match component.sections[0] {
    @core.ComponentSection::CoreModule(module_) => {
      // The module should have one function type
      assert_eq(module_.types.length(), 1)
      // The module should have one function
      assert_eq(module_.funcs.length(), 1)
      // The module should have one export named "add"
      assert_eq(module_.exports.length(), 1)
    }
    _ => fail("Expected CoreModule section")
  }
}

///|
test "parse component magic" {
  // Invalid magic number
  let invalid_magic : Bytes = b"\x00\x00\x00\x00\x0d\x00\x01\x00"
  let result = try {
    let _ = parse_component(invalid_magic)
    Ok(())
  } catch {
    ParseError::InvalidMagic => Err("InvalidMagic")
    _ => Err("Other error")
  }
  assert_eq(result, Err("InvalidMagic"))
}

///|
test "parse component version" {
  // Valid magic but invalid version (using core wasm version 0x01)
  let invalid_version : Bytes = b"\x00\x61\x73\x6d\x01\x00\x00\x00"
  let result = try {
    let _ = parse_component(invalid_version)
    Ok(())
  } catch {
    ParseError::UnsupportedVersion => Err("InvalidVersion")
    _ => Err("Other error")
  }
  assert_eq(result, Err("InvalidVersion"))
}

///|
test "parse component layer" {
  // Valid magic, valid version but invalid layer (using 0x00 instead of 0x01)
  let invalid_layer : Bytes = b"\x00\x61\x73\x6d\x0d\x00\x00\x00"
  let result = try {
    let _ = parse_component(invalid_layer)
    Ok(())
  } catch {
    ParseError::InvalidLayer => Err("InvalidLayer")
    _ => Err("Other error")
  }
  assert_eq(result, Err("InvalidLayer"))
}

///|
test "parse empty component" {
  // Valid component header with no sections
  let empty : Bytes = b"\x00\x61\x73\x6d\x0d\x00\x01\x00"
  let component = parse_component(empty)
  assert_eq(component.sections.length(), 0)
}

///|
test "parse full component from wasm-tools" {
  // Full component binary generated by wasm-tools component new
  // Sections: 1 (Core Module), 2 (Core Instance), 0 (Custom), 0 (Custom)
  let bytes : Bytes = b"\x00\x61\x73\x6d\x0d\x00\x01\x00\x01\x29\x00\x61\x73\x6d\x01\x00\x00\x00\x01\x07\x01\x60\x02\x7f\x7f\x01\x7f\x03\x02\x01\x00\x07\x07\x01\x03\x61\x64\x64\x00\x00\x0a\x09\x01\x07\x00\x20\x00\x20\x01\x6a\x0b\x02\x04\x01\x00\x00\x00\x00\x25\x0e\x63\x6f\x6d\x70\x6f\x6e\x65\x6e\x74\x2d\x6e\x61\x6d\x65\x01\x09\x00\x11\x01\x00\x04\x6d\x61\x69\x6e\x01\x09\x00\x12\x01\x00\x04\x6d\x61\x69\x6e\x00\x2f\x09\x70\x72\x6f\x64\x75\x63\x65\x72\x73\x01\x0c\x70\x72\x6f\x63\x65\x73\x73\x65\x64\x2d\x62\x79\x01\x0d\x77\x69\x74\x2d\x63\x6f\x6d\x70\x6f\x6e\x65\x6e\x74\x07\x30\x2e\x32\x34\x34\x2e\x30"
  let component = parse_component(bytes)

  // Should have multiple sections
  assert_true(component.sections.length() >= 2)

  // First section should be a core module
  match component.sections[0] {
    @core.ComponentSection::CoreModule(module_) => {
      assert_eq(module_.types.length(), 1)
      assert_eq(module_.funcs.length(), 1)
      assert_eq(module_.exports.length(), 1)
    }
    _ => fail("Expected CoreModule section as first section")
  }

  // Second section should be a core instance
  match component.sections[1] {
    @core.ComponentSection::CoreInstance(_) => ()
    _ => fail("Expected CoreInstance section as second section")
  }
}

///|
async test "parse component with types from file" {
  // Component with Type and Export sections generated from WIT
  let path = @path.Path("test/component/with-types.wasm").to_string()
  let file = @fs.open(path, mode=ReadOnly)
  defer file.close()
  let bytes = file.read_all().binary()
  let component = parse_component(bytes)

  // Should have 6 sections: Type, Export, Type, Export, Custom, Custom
  assert_eq(component.sections.length(), 6)

  // First section should be a Type
  match component.sections[0] {
    @core.ComponentSection::Type(_) => ()
    _ => fail("Expected Type section as first section")
  }

  // Second section should be an Export
  match component.sections[1] {
    @core.ComponentSection::Export(_) => ()
    _ => fail("Expected Export section as second section")
  }
}

///|
async test "parse simple component from file" {
  let path = @path.Path("test/component/simple.wasm").to_string()
  let file = @fs.open(path, mode=ReadOnly)
  defer file.close()
  let bytes = file.read_all().binary()
  let component = parse_component(bytes)

  // Should have 4 sections: Core Module, Core Instance, Custom, Custom
  assert_eq(component.sections.length(), 4)
  match component.sections[0] {
    @core.ComponentSection::CoreModule(module_) =>
      assert_eq(module_.exports.length(), 1)
    _ => fail("Expected CoreModule section")
  }
}

///|
async test "parse component with canonical lift" {
  // Component with canon lift:
  // - Core module with "add" function
  // - Core instance
  // - Component type (function type)
  // - Alias (core func export)
  // - Canon lift (lifts core func to component func)
  // - Export (exports the lifted function)
  let path = @path.Path("test/component/with-canon.wasm").to_string()
  let file = @fs.open(path, mode=ReadOnly)
  defer file.close()
  let bytes = file.read_all().binary()
  let component = parse_component(bytes)

  // Sections: CoreModule, CoreInstance, Type, Alias, Canon, Export, Custom, Custom
  assert_true(component.sections.length() >= 6)

  // First section should be a Core Module
  match component.sections[0] {
    @core.ComponentSection::CoreModule(module_) =>
      // Module should have "add" function and "memory" export
      assert_eq(module_.exports.length(), 2)
    _ => fail("Expected CoreModule section as first section")
  }

  // Second section should be a Core Instance
  match component.sections[1] {
    @core.ComponentSection::CoreInstance(_) => ()
    _ => fail("Expected CoreInstance section as second section")
  }

  // Third section should be a Type (function type for add)
  match component.sections[2] {
    @core.ComponentSection::Type(type_def) =>
      match type_def {
        @core.ComponentTypeDef::Func(func_type) => {
          // Function type: (param "a" s32) (param "b" s32) (result s32)
          assert_eq(func_type.params.length(), 2)
          assert_eq(func_type.results.length(), 1)
        }
        _ => fail("Expected Func type definition")
      }
    _ => fail("Expected Type section as third section")
  }

  // Fourth section should be an Alias (core func export)
  match component.sections[3] {
    @core.ComponentSection::Alias(alias_def) =>
      // Verify we have an alias with CoreExport or Export target
      match alias_def.target {
        @core.AliasTarget::CoreExport(instance_idx, name) => {
          assert_eq(instance_idx, 0)
          // Compare bytes directly to avoid encoding issues
          assert_eq(name, b"add")
        }
        @core.AliasTarget::Export(instance_idx, name) => {
          // Also accept Export target (depends on encoding)
          assert_eq(instance_idx, 0)
          assert_eq(name, b"add")
        }
        _ => fail("Expected CoreExport or Export alias target")
      }
    _ => fail("Expected Alias section as fourth section")
  }

  // Fifth section should be a Canon (lift)
  match component.sections[4] {
    @core.ComponentSection::Canon(canon) =>
      match canon {
        @core.Canon::Lift(core_func_idx, opts, type_idx) => {
          assert_eq(core_func_idx, 0)
          assert_eq(opts.length(), 0) // No options
          assert_eq(type_idx, 0)
        }
        _ => fail("Expected Canon::Lift")
      }
    _ => fail("Expected Canon section as fifth section")
  }

  // Sixth section should be an Export
  match component.sections[5] {
    @core.ComponentSection::Export(export_def) =>
      // Export name should be "add"
      assert_eq(export_def.name, b"add")
    _ => fail("Expected Export section as sixth section")
  }
}

///|
async test "parse component with table and global aliases" {
  // Component with table, global, memory, and func aliases
  let path = @path.Path("test/component/with-table-global.wasm").to_string()
  let file = @fs.open(path, mode=ReadOnly)
  defer file.close()
  let bytes = file.read_all().binary()
  let component = parse_component(bytes)

  // Count different alias types
  let mut table_aliases = 0
  let mut global_aliases = 0
  let mut memory_aliases = 0
  let mut func_aliases = 0
  for section in component.sections {
    match section {
      @core.ComponentSection::Alias(alias_def) =>
        match alias_def.kind {
          @core.AliasKind::CoreTable => table_aliases = table_aliases + 1
          @core.AliasKind::CoreGlobal => global_aliases = global_aliases + 1
          @core.AliasKind::CoreMemory => memory_aliases = memory_aliases + 1
          @core.AliasKind::CoreFunc => func_aliases = func_aliases + 1
          _ => ()
        }
      _ => ()
    }
  }

  // Verify we have the expected aliases
  assert_eq(table_aliases, 1)
  assert_eq(global_aliases, 1)
  assert_eq(memory_aliases, 1)
  assert_eq(func_aliases, 2)
}

///|
async test "parse component with canonical lift and options" {
  // Component with canon lift with options (memory, realloc)
  let path = @path.Path("test/component/with-canon-opts.wasm").to_string()
  let file = @fs.open(path, mode=ReadOnly)
  defer file.close()
  let bytes = file.read_all().binary()
  let component = parse_component(bytes)

  // Find the Canon section and verify options are parsed
  let mut found_canon = false
  for section in component.sections {
    match section {
      @core.ComponentSection::Canon(canon) =>
        match canon {
          @core.Canon::Lift(_, opts, _) => {
            // Should have 2 options: Memory and Realloc
            assert_eq(opts.length(), 2)
            // First option should be Memory(0)
            match opts[0] {
              @core.CanonOpt::Memory(idx) => assert_eq(idx, 0)
              _ => fail("Expected Memory option")
            }
            // Second option should be Realloc(0)
            match opts[1] {
              @core.CanonOpt::Realloc(idx) => assert_eq(idx, 0)
              _ => fail("Expected Realloc option")
            }
            found_canon = true
          }
          _ => ()
        }
      _ => ()
    }
  }
  assert_true(found_canon)
}

///|
async test "parse component with import and canon lower" {
  // Component with import:
  // - Import "host:math" func
  // - Core module with imported host function
  // - Canon lower (lowers component func to core func)
  // - Core instance
  // - Alias core export
  // - Canon lift
  // - Export
  let path = @path.Path("test/component/with-import.wasm").to_string()
  let file = @fs.open(path, mode=ReadOnly)
  defer file.close()
  let bytes = file.read_all().binary()
  let component = parse_component(bytes)

  // Count different section types
  let mut import_count = 0
  let mut canon_lift_count = 0
  let mut canon_lower_count = 0
  let mut export_count = 0
  let mut alias_count = 0
  for section in component.sections {
    match section {
      @core.ComponentSection::Import(_) => import_count = import_count + 1
      @core.ComponentSection::Canon(canon) =>
        match canon {
          @core.Canon::Lift(_, _, _) => canon_lift_count = canon_lift_count + 1
          @core.Canon::Lower(_, _) => canon_lower_count = canon_lower_count + 1
          _ => ()
        }
      @core.ComponentSection::Export(_) => export_count = export_count + 1
      @core.ComponentSection::Alias(_) => alias_count = alias_count + 1
      _ => ()
    }
  }

  // Verify we have the expected sections
  assert_eq(import_count, 1)
  assert_eq(canon_lower_count, 1)
  assert_eq(canon_lift_count, 1)
  assert_eq(export_count, 1)
  assert_eq(alias_count, 1)

  // Verify import details
  for section in component.sections {
    match section {
      @core.ComponentSection::Import(import_def) => {
        // Import name should be "host:math"
        assert_eq(import_def.name, b"host:math")
        // Should import a function (type 0)
        match import_def.desc {
          @core.ComponentExternDesc::Func(idx) => assert_eq(idx, 0)
          _ => fail("Expected function import")
        }
      }
      _ => ()
    }
  }

  // Verify canon lower
  for section in component.sections {
    match section {
      @core.ComponentSection::Canon(canon) =>
        match canon {
          @core.Canon::Lower(func_idx, opts) => {
            // Should lower func 0 (the imported function)
            assert_eq(func_idx, 0)
            // No options for simple integer params
            assert_eq(opts.length(), 0)
          }
          _ => ()
        }
      _ => ()
    }
  }
}

///|
async test "parse nested component" {
  // Component containing a nested component:
  // - Inner component with core module, canon lift, export
  // - Outer component instantiates inner, aliases export
  // - Outer core module uses lowered function from inner
  // - Canon lift and export from outer
  let path = @path.Path("test/component/nested.wasm").to_string()
  let file = @fs.open(path, mode=ReadOnly)
  defer file.close()
  let bytes = file.read_all().binary()
  let component = parse_component(bytes)

  // Count sections
  let mut nested_component_count = 0
  let mut instance_count = 0
  let mut alias_count = 0
  let mut canon_count = 0
  let mut export_count = 0
  for section in component.sections {
    match section {
      @core.ComponentSection::Component(_) =>
        nested_component_count = nested_component_count + 1
      @core.ComponentSection::Instance(_) => instance_count = instance_count + 1
      @core.ComponentSection::Alias(_) => alias_count = alias_count + 1
      @core.ComponentSection::Canon(_) => canon_count = canon_count + 1
      @core.ComponentSection::Export(_) => export_count = export_count + 1
      _ => ()
    }
  }

  // Should have 1 nested component
  assert_eq(nested_component_count, 1)
  // Should have 1 component instance (instantiate inner)
  assert_eq(instance_count, 1)
  // Should have multiple aliases (export from inner, core export)
  assert_true(alias_count >= 2)
  // Should have canon lower and lift
  assert_true(canon_count >= 2)
  // Should have export
  assert_eq(export_count, 1)

  // Verify the nested component has its own sections
  for section in component.sections {
    match section {
      @core.ComponentSection::Component(nested) => {
        // Inner component should have core module, core instance, type, alias, canon, export
        let mut has_core_module = false
        let mut has_export = false
        for inner_section in nested.sections {
          match inner_section {
            @core.ComponentSection::CoreModule(_) => has_core_module = true
            @core.ComponentSection::Export(exp) => {
              assert_eq(exp.name, b"double")
              has_export = true
            }
            _ => ()
          }
        }
        assert_true(has_core_module)
        assert_true(has_export)
      }
      _ => ()
    }
  }
}

///|
async test "parse component with start section" {
  // Component with start section that calls init function on instantiation
  let path = @path.Path("test/component/with-start.wasm").to_string()
  let file = @fs.open(path, mode=ReadOnly)
  defer file.close()
  let bytes = file.read_all().binary()
  let component = parse_component(bytes)

  // Find start section
  let mut found_start = false
  for section in component.sections {
    match section {
      @core.ComponentSection::Start(start) => {
        // Start function index should be 0
        assert_eq(start.func_idx, 0)
        // No arguments
        assert_eq(start.args.length(), 0)
        // No results
        assert_eq(start.results, 0)
        found_start = true
      }
      _ => ()
    }
  }
  assert_true(found_start)
}

///|
async test "parse component with multiple imports and exports" {
  // Component with multiple imports and exports
  let path = @path.Path("test/component/multi-import-export.wasm").to_string()
  let file = @fs.open(path, mode=ReadOnly)
  defer file.close()
  let bytes = file.read_all().binary()
  let component = parse_component(bytes)

  // Count imports and exports
  let mut import_count = 0
  let mut export_count = 0
  for section in component.sections {
    match section {
      @core.ComponentSection::Import(_) => import_count = import_count + 1
      @core.ComponentSection::Export(_) => export_count = export_count + 1
      _ => ()
    }
  }

  // Should have 3 imports (add, sub, mul)
  assert_eq(import_count, 3)
  // Should have 3 exports (add-mul, square, diff-squared)
  assert_eq(export_count, 3)
}

///|
async test "parse component with complex value types" {
  // Component with various value types: record, variant, enum, flags, tuple, option, result, list
  let path = @path.Path("test/component/complex-types.wasm").to_string()
  let file = @fs.open(path, mode=ReadOnly)
  defer file.close()
  let bytes = file.read_all().binary()
  let component = parse_component(bytes)

  // Should have at least one Type section
  let mut type_count = 0
  for section in component.sections {
    match section {
      @core.ComponentSection::Type(_) => type_count = type_count + 1
      _ => ()
    }
  }
  assert_true(type_count >= 1)
}

///|
async test "parse component with resource types" {
  // Component with resource type: counter with constructor, methods
  let path = @path.Path("test/component/with-resource.wasm").to_string()
  let file = @fs.open(path, mode=ReadOnly)
  defer file.close()
  let bytes = file.read_all().binary()
  let component = parse_component(bytes)

  // Should have at least one Type section (the component type with resource)
  let mut type_count = 0
  for section in component.sections {
    match section {
      @core.ComponentSection::Type(_) => type_count = type_count + 1
      _ => ()
    }
  }
  assert_true(type_count >= 1)
}
